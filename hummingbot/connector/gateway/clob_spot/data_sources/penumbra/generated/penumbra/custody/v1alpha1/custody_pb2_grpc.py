# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

from hummingbot.connector.gateway.clob_spot.data_sources.penumbra.generated.penumbra.custody.v1alpha1 import (
    custody_pb2 as penumbra_dot_custody_dot_v1alpha1_dot_custody__pb2,
)


class CustodyProtocolServiceStub(object):
    """The custody protocol is used by a wallet client to request authorization for
    a transaction they've constructed.

    Modeling transaction authorization as an asynchronous RPC call encourages
    software to be written in a way that has a compatible data flow with a "soft
    HSM", threshold signing, a hardware wallet, etc.

    The custody protocol does not trust the client to authorize spends, so
    custody requests must contain sufficient information for the custodian to
    understand the transaction and determine whether or not it should be
    authorized.
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.Authorize = channel.unary_unary(
                '/penumbra.custody.v1alpha1.CustodyProtocolService/Authorize',
                request_serializer=penumbra_dot_custody_dot_v1alpha1_dot_custody__pb2.AuthorizeRequest.SerializeToString,
                response_deserializer=penumbra_dot_custody_dot_v1alpha1_dot_custody__pb2.AuthorizeResponse.FromString,
                )


class CustodyProtocolServiceServicer(object):
    """The custody protocol is used by a wallet client to request authorization for
    a transaction they've constructed.

    Modeling transaction authorization as an asynchronous RPC call encourages
    software to be written in a way that has a compatible data flow with a "soft
    HSM", threshold signing, a hardware wallet, etc.

    The custody protocol does not trust the client to authorize spends, so
    custody requests must contain sufficient information for the custodian to
    understand the transaction and determine whether or not it should be
    authorized.
    """

    def Authorize(self, request, context):
        """Requests authorization of the transaction with the given description.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_CustodyProtocolServiceServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'Authorize': grpc.unary_unary_rpc_method_handler(
                    servicer.Authorize,
                    request_deserializer=penumbra_dot_custody_dot_v1alpha1_dot_custody__pb2.AuthorizeRequest.FromString,
                    response_serializer=penumbra_dot_custody_dot_v1alpha1_dot_custody__pb2.AuthorizeResponse.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'penumbra.custody.v1alpha1.CustodyProtocolService', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


# This class is part of an EXPERIMENTAL API.
class CustodyProtocolService(object):
    """The custody protocol is used by a wallet client to request authorization for
    a transaction they've constructed.

    Modeling transaction authorization as an asynchronous RPC call encourages
    software to be written in a way that has a compatible data flow with a "soft
    HSM", threshold signing, a hardware wallet, etc.

    The custody protocol does not trust the client to authorize spends, so
    custody requests must contain sufficient information for the custodian to
    understand the transaction and determine whether or not it should be
    authorized.
    """

    @staticmethod
    def Authorize(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/penumbra.custody.v1alpha1.CustodyProtocolService/Authorize',
            penumbra_dot_custody_dot_v1alpha1_dot_custody__pb2.AuthorizeRequest.SerializeToString,
            penumbra_dot_custody_dot_v1alpha1_dot_custody__pb2.AuthorizeResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
